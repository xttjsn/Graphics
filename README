This is the readme file for sceneview.

In this assignment I implemented the logic of building the shapes by using the data provided by the
CS123XMLSceneParser.

As described in the algo, I created a class in CS123SceneData.h called "CS123TransfromPrimitive",
which has the following three member variables.

    glm::mat4x4 transform;
    CS123ScenePrimitive primitive;
    std::unique_ptr<OpenGLShape> shape;

The "transform" matrix is the "aggregated" transform matrix of the primitive, which is the product
of all its parent nodes' transforms as well as its own transforms, multiplied in a top first
order. We store such a matrix for each primitive in the scene so that we don't have to re-traverse
the tree again in the future. We only create such an object for primitives because those are what
ultimately gets drawn and nodes' like "master" are only relevant because they apply transforms to
their children nodes. Once we've computed all the "aggregated" transform matrix for all the leaf
node (i.e. primitives), we no longer need their parents.

We also included a unique_ptr of the class OpenGLShape (from Shape) in the class, because that way
we can keep track of whether the shape's vertices have already been computed, and we can reuse
those vertices in such cases.

So, each Scene contains a std::vector<CS123TransformPrimitive> called "transPrim", and we build this
via calling the function "parseNode" recursively in Scene.cpp. This function accepts a Scene
pointer, a node, and a transform matrix. It will first compute the local transform matrix and then
the product of the "inherited" transform matrix with it. If this node is primitive, it will add a
primitive to "transPrim". Then for every child it has, we call "parseNode" again.


Bugs:

No known bugs
