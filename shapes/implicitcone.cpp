#include "implicitcone.h"

ImplicitCone::ImplicitCone()
{
}

Intersect ImplicitCone::intersect(const Ray& ray) {
    float t, x, y, z, t_body, t_cap;
    bool intersectBody = false, intersectCap = false;
    glm::vec4 start_obj = m_transform_inv * ray.start; // The start point in object space
    glm::vec4 delta_obj = m_transform_inv * ray.delta; // The delta vector in object space
    float px = start_obj.x;
    float py = start_obj.y;
    float pz = start_obj.z;
    float dx = delta_obj.x;
    float dy = delta_obj.y;
    float dz = delta_obj.z;

    /******************* Cone Body *********************/
    float a = dy * dy - 4 * (dx * dx + dz * dz);
    float b = -8 *(dx * px+ dz * pz) + dy - 2 * dy * py;
    float c = (py - 0.5) * (py - 0.5) - 4 * (px * px + pz * pz) * (px * pz + pz * pz);

    float t1 = (-b + glm::sqrt(b * b - 4 * a * c)) / (2 * a);
    float t2 = (-b - glm::sqrt(b * b - 4 * a * c)) / (2 * a);

    float y1 = py + t1 * dy;
    float y2 = py + t2 * dy;

    // Both intersections are valid
    if (-0.5 <= y1 && y1 <= 0.5 && -0.5 <= y2 && y2 <= 0.5) {
        t_body = glm::min(t1, t2);
        y = t_body == t1 ? y1 : y2;
        intersectBody = true;
    }
    // Only y1 is valid
    else if (-0.5 <= y1 && y1 <= 0.5) {
        t_body = t1;
        y = y1;
        intersectBody = true;
    }
    // Only y2 is valid
    else if (-0.5 <= y2 && y2 <= 0.5) {
        t_body = t2;
        y = y2;
        intersectBody = true;
    } else {
        // Does not intersect with body
    }

    /******************* Cone Cap ***********************/
    t_cap = -(0.5 + py) / dy;
    float x_intersect = px + dx * t_cap;
    float z_intersect = pz + dz * t_cap;
    float radius = x_intersect * x_intersect + z_intersect * z_intersect;
    if (radius <= 0.25)
        intersectCap = true;

    /****************** Cone Body and Cone Cap *****************/
    if (intersectBody && intersectCap) {
        t = glm::min(t_body, t_cap);
    } else if (intersectBody) {
        t = t_body;
    } else if (intersectCap) {
        t = t_cap;
    } else {
        return Intersect(true, glm::vec4(0));
    }

    x = px + dx * t;
    y = py + dy * t;
    z = pz + dz * t;
    glm::vec4 pos(x, y, z, 1);
    pos = m_transform * pos;
    return Intersect(false, pos);
}

glm::vec4 ImplicitCone::normal(Intersect& intersect) {
    // Assume the intersect is genuinely generated by calling intersect(ray)
    // NOTE: we don't perform the intersect test here, therefore passing in untested
    // position might result in incorrect normal
    if (intersect.miss) return glm::vec4(0);

    glm::vec4 pos = intersect.pos, norm;
    pos = m_transform_inv * pos;        // Get intersection point in object space

    if (fequal(pos, -0.5)) {
        // Intersect lies on cone cap
        norm = glm::vec4(0, -1, 0, 0);  // Pointing downwards
    } else {
        // Intersect lies on cone body
        float x = pos.x, y = pos.y, z = pos.z;
        float phi = glm::tanh(z / x);
        glm::vec3 vApexToPos = glm::vec3(x, y - 0.5, z);
        glm::vec3 vPosTagent = glm::vec3(glm::cos(phi + PI / 2.0), 0, glm::sin(phi + PI / 2.0));
        norm = glm::vec4(glm::normalize(glm::cross(vApexToPos, vPosTagent)), 0);
    }

    norm = glm::normalize(m_transform * norm);  // Convert back to world space
    return norm;
}

float ImplicitCone::surfaceArea() {
    // Area = PI * r * (r + sqrt(h^2 + r^2))
    glm::vec4 center(0, -0.5, 0, 1);
    glm::vec4 apex(0, 0.5, 0, 1);
    glm::vec4 edge(0.5, -0.5, 0, 1);

    center = m_transform * center;
    apex = m_transform * apex;
    edge = m_transform * edge;

    float r = glm::distance(center, edge);
    float h = glm::distance(center, apex);
    return PI * r * (r + glm::sqrt(h * h + r * h));
}

BoundingBox ImplicitCone::boundingBox() {
    std::vector<glm::vec4> extremes = {
        glm::vec4(0, 0.5, 0, 1),        // Apex
        glm::vec4(-0.5, -0.5, 0, 1),    // Left
        glm::vec4(0, -0.5, -0.5, 1),    // Down
        glm::vec4(0.5, -0.5, 0, 1),     // Right
        glm::vec4(0, -0.5, 0.5, 1),     // Up
        glm::vec4(0.5 * glm::cos(PI / 4), -0.5, 0.5 * glm::sin(PI / 4), 1), // Right Up
        glm::vec4(0.5 * glm::cos(3 * PI / 4), -0.5, 0.5 * glm::sin(3 * PI / 4), 1), // Left Up
        glm::vec4(0.5 * glm::cos(5 * PI / 4), -0.5, 0.5 * glm::sin(5 * PI / 4), 1), // Left Down
        glm::vec4(0.5 * glm::cos(7 * PI / 4), -0.5, 0.5 * glm::sin(7 * PI / 4), 1), // Right Down
    };

    float xMin = FLT_MAX, xMax = -FLT_MAX,
          yMin = FLT_MAX, yMax = -FLT_MAX,
          zMin = FLT_MAX, zMax = -FLT_MAX;
    for (glm::vec4& e : extremes) {
        e = m_transform * e;
        xMin = glm::min(xMin, e.x);
        xMax = glm::max(xMax, e.x);
        yMin = glm::min(yMin, e.y);
        yMax = glm::max(yMax, e.y);
        zMin = glm::min(zMin, e.z);
        zMax = glm::max(zMax, e.z);
    }

    return BoundingBox(xMin, xMax, yMin, yMax, zMin, zMax);
}
