#include "implicitcone.h"
#include <algorithm>
#include <math.h>

ImplicitCone::ImplicitCone()
{
}

Intersect ImplicitCone::intersect(const Ray& ray) {
    float t, x, y, z, sq;
    std::vector<float> ts;
    glm::vec4 start_obj = m_transform_inv * ray.start; // The start point in object space
    glm::vec4 delta_obj = m_transform_inv * ray.delta; // The delta vector in object space
    float px = start_obj.x;
    float py = start_obj.y;
    float pz = start_obj.z;
    float dx = delta_obj.x;
    float dy = delta_obj.y;
    float dz = delta_obj.z;

    /******************* Cone Body *********************/
    float a = dx * dx + dz * dz - 0.25 * dy * dy;
    float b = 2 * px * dx + 2 * pz * dz - 0.5 * py * dy + 0.25 * dy;
    float c = px * px + pz * pz - 0.25 * py * py + 0.25 * py - 0.0625;

    sq = b * b - 4 * a * c;
    if (fequal(sq, 0.f)) {
        t = -b / (2 * a);
        y = py + dy * t;
        if (-0.5 <= y && y <= 0.5)
            ts.push_back(t);
    }
    else if (sq > 0) {
        t = (-b + glm::sqrt(sq)) / (2 * a);
        y = py + dy * t;
        if (-0.5 <= y && y <= 0.5)
            ts.push_back(t);

        t = (-b - glm::sqrt(sq)) / (2 * a);
        y = py + dy * t;
        if (-0.5 <= y && y <= 0.5)
            ts.push_back(t);
    }

    /******************* Cone Cap ***********************/
    t = -(0.5 + py) / dy;
    x = px + dx * t;
    z = pz + dz * t;
    float radius_sq = x * x + z * z;
    if (radius_sq <= 0.25)
        ts.push_back(t);

    /****************** Take the smallest *****************/

    if (ts.empty()) {
        return Intersect(true, glm::vec4(0), FLT_MAX);
    }

    t = *std::min_element(ts.begin(), ts.end());
    x = px + dx * t; y = py + dy * t; z = pz + dz * t;
    return Intersect(false, m_transform * glm::vec4(x, y, z, 1), t);
}

glm::vec4 ImplicitCone::normal(Intersect& intersect) {
    // Assume the intersect is genuinely generated by calling intersect(ray)
    // NOTE: we don't perform the intersect test here, therefore passing in untested
    // position might result in incorrect normal
    if (intersect.miss) return glm::vec4(0);

    glm::vec4 pos = intersect.pos, norm;
    pos = m_transform_inv * pos;        // Get intersection point in object space

    if (fequal2(pos.y, -0.5f)) {
        // Intersect lies on cone cap
        norm = glm::vec4(0, -1, 0, 0);  // Pointing downwards
    } else {
        // Intersect lies on cone body
        float x = pos.x, z = pos.z;
        float theta = std::atan2(0.5f, 1.0f);
        float phi = std::atan2(z, x);
        norm = glm::vec4(glm::cos(theta) * glm::cos(phi), glm::sin(theta), glm::cos(theta) * glm::sin(phi), 0);
    }

    return norm;
}

float ImplicitCone::surfaceArea() {
    // Area = PI * r * (r + sqrt(h^2 + r^2))
    glm::vec4 center(0, -0.5, 0, 1);
    glm::vec4 apex(0, 0.5, 0, 1);
    glm::vec4 edge(0.5, -0.5, 0, 1);

    center = m_transform * center;
    apex = m_transform * apex;
    edge = m_transform * edge;

    float r = glm::distance(center, edge);
    float h = glm::distance(center, apex);
    return PI * r * (r + glm::sqrt(h * h + r * h));
}

BoundingBox ImplicitCone::boundingBox() {
    std::vector<glm::vec4> extremes = {
        glm::vec4(0, 0.5, 0, 1),        // Apex
        glm::vec4(-0.5, -0.5, 0, 1),    // Left
        glm::vec4(0, -0.5, -0.5, 1),    // Down
        glm::vec4(0.5, -0.5, 0, 1),     // Right
        glm::vec4(0, -0.5, 0.5, 1),     // Up
        glm::vec4(0.5 * glm::cos(PI / 4), -0.5, 0.5 * glm::sin(PI / 4), 1), // Right Up
        glm::vec4(0.5 * glm::cos(3 * PI / 4), -0.5, 0.5 * glm::sin(3 * PI / 4), 1), // Left Up
        glm::vec4(0.5 * glm::cos(5 * PI / 4), -0.5, 0.5 * glm::sin(5 * PI / 4), 1), // Left Down
        glm::vec4(0.5 * glm::cos(7 * PI / 4), -0.5, 0.5 * glm::sin(7 * PI / 4), 1), // Right Down
    };

    float xMin = FLT_MAX, xMax = -FLT_MAX,
          yMin = FLT_MAX, yMax = -FLT_MAX,
          zMin = FLT_MAX, zMax = -FLT_MAX;
    for (glm::vec4& e : extremes) {
        e = m_transform * e;
        xMin = glm::min(xMin, e.x);
        xMax = glm::max(xMax, e.x);
        yMin = glm::min(yMin, e.y);
        yMax = glm::max(yMax, e.y);
        zMin = glm::min(zMin, e.z);
        zMax = glm::max(zMax, e.z);
    }

    return BoundingBox(xMin, xMax, yMin, yMax, zMin, zMax);
}
